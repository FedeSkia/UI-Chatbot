name: FE → ECR (script) → ECS rollout

on:
  push:
    branches: [ main ]
  workflow_dispatch:

permissions:
  id-token: write   # OIDC to assume AWS role
  contents: read

env:
  # ---- Build/Push parameters consumed by push-image.sh ----
  AWS_REGION: eu-west-1
  AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}      # e.g., 507881105499
  IMAGE_NAME: rag-langchain-app-fe
  ECR_REPOSITORY: rag-app
  SERVICE_TAG: rag-langchain-app-latest-fe

  # ---- ECS rollout params ----
  ECS_CLUSTER: ${{ secrets.ECS_CLUSTER }}            # e.g., cb-cluster
  ECS_SERVICE: ${{ secrets.ECS_SERVICE }}            # e.g., nginx-load-balancer

jobs:
  build-push-and-deploy:
    runs-on: ubuntu-latest
    environment: dev
    permissions:
      id-token: write
      contents: read
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # Optional (helpful if your Dockerfile builds linux/amd64 on GitHub runners)
      - name: Setup QEMU
        uses: docker/setup-qemu-action@v3
      - name: Setup Docker Buildx
        uses: docker/setup-buildx-action@v3

      # Assume AWS role via OIDC (no long-lived keys)
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.ROLE_ARN }}   # store the IAM role ARN in repo secrets
          aws-region: ${{ env.AWS_REGION }}

      # Run your script (uses env above)
      - name: Make script executable
        run: chmod +x ./push-image.sh
      - name: Build & push via script
        run: ./push-image.sh

      # Roll ECS service so tasks pull the new tag
      - name: Force new ECS deployment
        run: |
          aws ecs update-service \
            --cluster "${ECS_CLUSTER}" \
            --service "${ECS_SERVICE}" \
            --force-new-deployment

      - name: Wait for service stability
        run: |
          aws ecs wait services-stable \
            --cluster "${ECS_CLUSTER}" \
            --services "${ECS_SERVICE}"
